//! Compiles a GLSL shader, extracts info from it, and generates a Zig file with everything you need.
//! Usage: ./zhader -fshader-stage=shader-stage input.glsl output.spv output.zig
//! The arguments have to be in that order
//! Supported shader stages are 'vertex' and 'fragment'
const std = @import("std");

// a bunch of shader stuff for the json parser
const ShaderReflect = struct {
    entryPoints: []ShaderEntryPoint = &[_]ShaderEntryPoint{},
    inputs: []ShaderInputOutput = &[_]ShaderInputOutput{},
    outputs: []ShaderInputOutput = &[_]ShaderInputOutput{},
};

const ShaderEntryPoint = struct {
    name: []const u8,
    mode: []const u8,
};

const ShaderInputOutput = struct {
    name: []const u8,
    type: []const u8,
    location: u32,
};

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}).init;
    defer _ = gpa.deinit();
    var arena = std.heap.ArenaAllocator.init(gpa.allocator());
    defer arena.deinit();
    const alloc = arena.allocator();

    const argv = try std.process.argsAlloc(alloc);
    defer std.process.argsFree(alloc, argv);
    if (argv.len != 5) {
        for (argv) |arg| {
            std.debug.print("fucking arg: {s}\n", .{arg});
        }
        std.debug.panic("rtfm dumbass", .{});
    }

    const shader_stage = argv[1]; // conveniently it maps directly to a glslc flag
    const src = argv[2];
    const output_spirv = argv[3];
    const output_zig = argv[4];

    // i am compiling it
    const glslc_cmd = try std.process.Child.run(.{
        .argv = &[_][]const u8{
            "glslc",
            "--target-env=vulkan1.2",
            shader_stage,
            "-o",
            output_spirv,
            src,
        },
        .allocator = alloc,
    });
    _ = try std.fs.File.stdout().write(glslc_cmd.stdout);
    _ = try std.fs.File.stderr().write(glslc_cmd.stderr);
    defer alloc.free(glslc_cmd.stdout);
    defer alloc.free(glslc_cmd.stderr);

    // i am reflecting it
    const spirv_cross_cmd = try std.process.Child.run(.{
        .argv = &[_][]const u8{
            "spirv-cross",
            output_spirv,
            "--reflect",
            "--output",
            try std.mem.concat(alloc, u8, &[_][]const u8{ output_spirv, ".json" }),
        },
        .allocator = alloc,
    });
    _ = try std.fs.File.stdout().write(spirv_cross_cmd.stdout);
    _ = try std.fs.File.stderr().write(spirv_cross_cmd.stderr);
    defer alloc.free(spirv_cross_cmd.stdout);
    defer alloc.free(spirv_cross_cmd.stderr);

    // i am parsing it
    const reflect_txt = try std.fs.cwd().readFileAlloc(
        alloc,
        try std.mem.concat(alloc, u8, &[_][]const u8{ output_spirv, ".json" }),
        std.math.maxInt(usize),
    );
    const reflect: ShaderReflect = try std.json.parseFromSliceLeaky(
        ShaderReflect,
        alloc,
        reflect_txt,
        .{
            .ignore_unknown_fields = true,
        },
    );
    const spirv = try std.fs.cwd().readFileAlloc(alloc, output_spirv, std.math.maxInt(usize));

    // i am generating it
    // TODO uniforms and other shader shit
    var finalsrc = try std.fs.cwd().createFile(output_zig, .{ .read = true });
    defer finalsrc.close();
    var almost_writer = finalsrc.writer(&.{});
    const writer = &almost_writer.interface;

    try writer.print("//! Autogenerated by zhader from {s}\n", .{src});

    _ = try writer.write("pub const spirv: []const u8 = .{\n    ");
    try finalsrc.sync();
    for (spirv) |byte| {
        try writer.print("0x{x:02}, ", .{byte});
    }
    _ = try writer.write("\n};\n\n");

    for (reflect.inputs) |input| {
        try writer.print("pub const {s}_location: u32 = {d};\n", .{ input.name, input.location });
    }
    for (reflect.outputs) |output| {
        try writer.print("pub const {s}_location: u32 = {d};\n", .{ output.name, output.location });
    }
    try writer.flush();
}
